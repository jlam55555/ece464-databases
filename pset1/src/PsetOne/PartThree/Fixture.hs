{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilies #-}

module PsetOne.PartThree.Fixture where

import           PsetOne.PartThree.Schema
import           PsetOne.Util

import           Database.Beam
import           Database.Beam.Backend.SQL.BeamExtensions
import           Database.Beam.Postgres

import           Database.Beam.Backend.SQL
import           Database.Beam.Backend.Types

import           Data.Fixed
import           Data.Int
import           Data.Maybe                     ( isJust )
import           Data.Text                      ( Text )
import           Data.Time

-- TODO: move a lot of this to schema file
-- TODO: generate some test queries to show functionality
-- TODO: write-up about everything
-- TODO: add more test cases

-- helper to print out each item on new line;
-- query is some query that returns an (IO item) type
showLines :: (Show a) => IO [a] -> IO ()
showLines = flip (>>=) (\list -> mapM_ (putStrLn . show) list)

-- helper to insert tuples into a table and return the created entries
-- (the tuples may contain incomplete information; e.g., it may not have the
-- autocomputed ID column that is generated by the DB on insert)
-- (the large context is necessary to make `runInsertReturningList` happy)
makeInserter
  :: ( Beamable t
     , Projectible Postgres (t (QExpr Postgres ()))
     , FromBackendRow Postgres (t Identity)
     )
  => DatabaseEntity Postgres CompanyDb (TableEntity t)
  -> (forall s . a -> t (QExpr Postgres s))
  -> [a]
  -> IO [t Identity]
makeInserter table entryConverter entries =
  run $ runInsertReturningList $ insert table $ insertExpressions $ map
    entryConverter
    entries

-- helper functions for time literals
makeDay = fromGregorian
makeTime yyyy mM dd hh mm ss =
  LocalTime (fromGregorian yyyy mM dd) (TimeOfDay hh mm ss)

-- helper functions to convert to rescope query variables
rescopeSailor Sailor { sailorSid = sid, sailorSname = sname, sailorRating = rating, sailorDob = dob }
  = Sailor (val_ sid) (val_ sname) (val_ rating) (val_ dob)
rescopeEmployee Employee { employeeEid = eid, employeeEname = ename, employeeDob = dob, employeeWage = wage }
  = Employee (val_ eid) (val_ ename) (val_ dob) (val_ wage)
rescopeBoat Boat { boatBid = bid, boatBname = bname, boatColor = color, boatLength = length }
  = Boat (val_ bid) (val_ bname) (val_ color) (val_ length)
rescopePayment Payment { paymentPid = pid, paymentSid = sid, paymentCost = cost, paymentTime = time, paymentType = paymentType }
  = Payment (val_ pid) (val_ sid) (val_ cost) (val_ time) (val_ paymentType)
rescopeEquipment Equipment { equipmentEqid = eqid, equipmentName = name, equipmentDsc = dsc, equipmentCount = count, equipmentCost = cost }
  = Equipment (val_ eqid) (val_ name) (val_ dsc) (val_ count) (val_ cost)
rescopeReserves Reserves { reservesRid = rid, reservesSid = sid, reservesBid = bid, reservesEid = eid, reservesPid = pid, reservesDay = day }
  = Reserves (val_ rid) (val_ sid) (val_ bid) (val_ eid) (val_ pid) (val_ day)

-- functions to perform insert instructions
insertSailors = makeInserter sailorsTable $ \(name, rating, (yyyy, mm, dd)) ->
  Sailor default_ (val_ name) (val_ rating) (val_ $ makeDay yyyy mm dd)

insertEmployees = makeInserter
  employeesTable
  (\(name, (yyyy, mm, dd), wage) ->
    Employee default_ (val_ name) (val_ $ makeDay yyyy mm dd) (val_ wage)
  )

insertBoats = makeInserter
  boatsTable
  (\(name, color, length) ->
    Boat default_ (val_ name) (val_ color) (val_ length)
  )

insertEquipment = makeInserter
  equipmentTable
  (\(name, dsc, count, cost) ->
    Equipment default_ (val_ name) (val_ dsc) (val_ count) (val_ cost)
  )

insertClockTimes = makeInserter
  clockTimesTable
  (\(employee, timestamp, clockType) -> ClockTime
    (pk $ rescopeEmployee employee)
    (val_ timestamp)
    (val_ clockType)
  )
clockIn employee time = (employee, time, True)
clockOut employee time = (employee, time, False)

insertPayments
  :: [(Either Sailor SailorId, Int32, LocalTime, PaymentType)] -> IO [Payment]
insertPayments = makeInserter
  paymentsTable
  (\(sailor, cost, time, paymentType) -> Payment
    default_
    (case sailor of
      Left  sailor -> pk $ rescopeSailor sailor
      Right sid    -> val_ sid
    )
    (val_ cost)
    (val_ time)
    (val_ paymentType)
  )

-- reservation includes information about the reservation and payment
insertReservations entries = do
  payments <- insertPayments
    (map
      (\(sailor, _, _, time, cost) -> (Left sailor, cost, time, ReservesPayment)
      )
      entries
    )
  makeInserter
      reservesTable
      (\((sailor, boat, employee, time, _), payment) -> Reserves
        default_
        (pk $ rescopeSailor sailor)
        (pk $ rescopeBoat boat)
        (pk $ rescopeEmployee employee)
        (pk $ rescopePayment payment)
        (val_ $ localDay time)
      )
    $ zip entries payments

-- matches up holes in original maybe with the second array; example:
--     matchHoles [-2.4, 3.5, 52.0] [Just 4, Nothing, Nothing, Just 3, Just 2, Nothing]
--     -> [Just (-2.4),Nothing,Nothing,Just 3.5,Just 52.0,Nothing]
-- This is used for optional costs in the incidents table
matchHoles :: [b] -> [Maybe a] -> [Maybe b]
matchHoles noHoles holey = reverse $ snd $ foldl
  (\(noHoles, newHoley) x -> case x of
    Just _  -> (tail noHoles, Just (head noHoles) : newHoley)
    Nothing -> (noHoles, Nothing : newHoley)
  )
  (noHoles, [])
  holey

-- incidents are associated with a reservation
-- incidents may optionally create a payment with it; most of the complexity
-- in this function comes from dealing with the optional value
-- [(reservation, time, severity, description, employee, resolved, resolution, cost)]
insertIncidents
  :: [(Reserves, LocalTime, Int32, Text, Employee, Bool, Text, Maybe Int32)]
  -> IO [Incident]
insertIncidents entries = do
  payments <- insertPayments
    ( map
        (\(reservation, time, _, _, _, _, _, Just cost) ->
          (Right $ reservesSid reservation, cost, time, IncidentPayment)
        )
    $ filter (\(_, _, _, _, _, _, _, cost) -> isJust cost) entries
    )
  makeInserter
      incidentsTable
      (\((reservation, time, severity, description, employee, resolved, resolution, _), payment) ->
        Incident
          default_
          (pk $ rescopeReserves reservation)
          (val_ time)
          (val_ severity)
          (val_ description)
          (val_ resolved)
          (pk $ rescopeEmployee employee)
          (val_ resolution)
          (case payment of
            Just payment -> just_ (pk $ rescopePayment payment)
            Nothing      -> nothing_
          )
      )
    $ zip entries
    $ matchHoles payments
    $ map (\(_, _, _, _, _, _, _, cost) -> cost) entries

-- equipment sale includes information about the equipment, sailor, and payment
insertEquipmentSales entries = do
  payments <- insertPayments
    (map
      (\(sailor, equipment, count, time) ->
        (Left sailor, equipmentCost equipment * count, time, EquipmentPayment)
      )
      entries
    )
  makeInserter
      equipmentSalesTable
      (\((sailor, equipment, count, _), payment) -> EquipmentSale
        (pk $ rescopePayment payment)
        (pk $ rescopeEquipment equipment)
        (pk $ rescopeSailor sailor)
        (val_ count)
      )
    $ zip entries payments

createFixture = do
  resetSchema
  -- names generated from http://listofrandomnames.com
  -- numbers generated from https://www.random.org/integers
  [hershel, joenn, vania, katheryn, shanika, madeleine, li, zachariah, marinda, clara] <-
    insertSailors
      [ ("Hershel"  , 7 , (1993, 3, 23))
      , ("Joeann"   , 1 , (1964, 10, 16))
      , ("Vania"    , 5 , (1983, 5, 16))
      , ("Katheryn" , 2 , (1997, 10, 19))
      , ("Shanika"  , 10, (2001, 3, 16))
      , ("Madeleine", 6 , (1963, 9, 11))
      , ("Li"       , 6 , (1990, 9, 17))
      , ("Zachariah", 6 , (1994, 1, 9))
      , ("Marinda"  , 5 , (1983, 8, 22))
      , ("Clara"    , 3 , (1987, 3, 24))
      ]
  [marsha, willard, bryon, chanelle, vikki] <- insertEmployees
    [ ("Marsha"  , (1992, 10, 10), 2000)
    , ("Willard" , (1982, 3, 22) , 2000)
    , ("Bryon"   , (1956, 11, 13), 4500)
    , ("Chanelle", (1977, 11, 2) , 3000)
    , ("Vikki"   , (2002, 5, 30) , 2000)
    ]
  -- boat names from:
  -- https://www.boatus.com/products-and-services/boat-lettering/boat-names
  [andiamo, socialDistancing, grace, shenanigans, coolChange, knotOnCall] <-
    insertBoats
      [ ("Andiamo"          , "red"  , 57)
      , ("Social Distancing", "green", 21)
      , ("Grace"            , "blue" , 52)
      , ("Shenanigans"      , "green", 49)
      , ("Cool Change"      , "red"  , 25)
      , ("Knot On Call"     , "red"  , 15)
      ]
  -- sample equipment from:
  -- https://www.velasailingsupply.com/sailboat-equipment/sailing-accessories/
  [boatHookEnd, reelTreatment, eyestrapKit, marineRotationPlate] <-
    insertEquipment
      [ ("Boat Hook End", "Allen Brothers 25MM Nylon Boat Hook End", 42, 723)
      , ("Reel Treatment", "ReelX Performance Reel Treatment", 10, 620)
      , ( "Soft eyestrap kit"
        , "This kit contains webbing and rivet with washer to mount this soft eyestrap, class rules let you replace the stock stainless steel lacing eyestrap in the middle of your boom with this soft strap."
        , 5
        , 707
        )
      , ( "Johnson Marine Rotation Plate"
        , "This plate allows 45deg of rotation in either vertical or horizontal plane. The plate mounts between the bracket and accessory unit on any of our \"40\" series mounts."
        , 15
        , 743
        )
      ]
  insertClockTimes
    [ clockIn marsha $ makeTime 2021 10 03 09 00 00
    , clockOut marsha $ makeTime 2000 10 03 17 01 00
    , clockIn marsha $ makeTime 2000 10 04 08 58 00
    , clockOut marsha $ makeTime 2000 10 04 17 00 00
    , clockIn marsha $ makeTime 2000 10 05 09 00 00
    , clockOut marsha $ makeTime 2000 10 05 17 00 00
    , clockIn marsha $ makeTime 2000 10 06 09 00 00
    , clockOut marsha $ makeTime 2000 10 06 17 00 00
    , clockIn willard $ makeTime 2000 10 03 08 58 00
    , clockOut willard $ makeTime 2000 10 03 17 00 00
    , clockIn willard $ makeTime 2000 10 04 08 58 00
    , clockOut willard $ makeTime 2000 10 04 17 00 00
    , clockIn bryon $ makeTime 2000 10 05 09 00 00
    , clockOut bryon $ makeTime 2000 10 05 17 00 00
    , clockIn bryon $ makeTime 2000 10 06 09 00 00
    , clockOut bryon $ makeTime 2000 10 06 17 00 00
    ]
  [rsv1, rsv2] <- insertReservations
    [ (hershel, andiamo   , marsha, makeTime 2020 10 03 12 01 52, 50)
    , (hershel, coolChange, marsha, makeTime 2020 10 04 12 01 52, 50)
    ]
  insertEquipmentSales
    [ (hershel, marineRotationPlate, 1, makeTime 2020 10 03 11 50 00)
    , (hershel, boatHookEnd        , 3, makeTime 2020 10 03 11 50 00)
    ]
  insertIncidents
    [ ( rsv1
      , makeTime 2020 10 03 13 00 02
      , 3
      , "boat ran aground"
      , marsha
      , False
      , "fixed hull"
      , Nothing
      )
    , ( rsv1
      , makeTime 2020 10 03 14 44 02
      , 3
      , "Boat sunk"
      , marsha
      , False
      , "bought new boat"
      , Just 1250000
      )
    ]
  pure ()
